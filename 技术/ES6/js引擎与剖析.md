ECMAScript标准只告诉了浏览器，如何让一段相同的JS执行后能产生相同的输出，即定义了JS的语法，关键字等，各个浏览器需要能解释这些JS语法，之后能执行它。

但它并没有规定每个浏览器内部应该怎么做，才能去解释这些JS语法和执行JS。浏览器内部的实现是每个浏览器厂商自家的实现。

## JS引擎从头说起

每一个浏览器都有一个内置的JS引擎，用于执行JS代码。最初的网景浏览器使用的JS引擎叫SpiderMonkey，它只是一个非常简陋的JS解释器，没有做任何优化，虽然处理JS比较慢，但却可以工作。

![](https://cdn.jsdelivr.net/gh/ywxgod/image_source/imgs20210528220406.png)

从上图我们知道，JS引擎的第一个任务是读取JS源代码，然后编译CPU能理解的二进制指令(机器码)。JS引擎包含了一个基线编译器，它负责将JS源码转为中间过程的字节码，接下来由解释器将字节码转为二进制指令输入到CPU。

基线编译器以尽可能快的速度将源码转为字节码，这些字节码没有经过优化，然后就传给了解释器，这回导致解释器变慢，从而影响到整个JS的执行速度。

>   现在的SpiderMonkey已经不再像以前，它已经对产出的字节码做了高度的优化，并且目前在FireFox浏览器中使用。

随着网络应用的大规模交互与动态化，上面的这种慢的JS执行解释模式，已经影响到用户体验了。当年谷歌浏览器在运行谷歌地图应用的时候就遇到这样的体验问题，所以为了提升JS的性能，以及用户体验，他们不得不想出一个更好的方法。

谷歌浏览器在初期使用的JS引擎叫V8，为了提升JS性能，他们给V8引擎的执行流程增加了2个东西，如下图

![](https://cdn.jsdelivr.net/gh/ywxgod/image_source/imgs20210528223029.png)

在2010年版的V8中，主要有两个东西负责重活：full-codegen(基线编译器)与crankshaft(负责优化的编译器)。前者主要负责尽可能快的产出未优化的二级制指令，以加快应用程序的启动；应用启动后，crankshaft编译器会启动来优化源代码，并替换full-codegen来产生优化过的二进制指令，以提升JS的运行性能。

然后上面的优化会消耗大量的CPU时间和内存，所以V8必须提出另外一种JS的执行和解析模式，它就是JIT模式。从上图中我们可以看出解释器已经不存在了，就是说JS源码直接变成了CPU能识别的二进制指令，并且是在边处理源码边生成二进制指令的，所以这加快了JS的执行效率。

上面是从流程上减少了解释器部分来优化，那从JS的执行考虑有做了哪些优化呢？

### JS优化

JS在进入基线编译器之前，它会被解析为AST，通过AST我们可以对源码进行优化，优化主要有以下两点：

-   优化JS代码中没必要的复杂逻辑。
-   基于已定义的变量值来猜测其出类型，以便于产出更加优化的机器码。

在优化JS的执行的同时，V8还会收集和分析JS的执行过程，找出其运行缓慢的地方。这些运行缓慢的代码会被进一步优化，以输出更加优化的机器码。

基于上面的分析和考虑，V8团队在2017年又发布了一个新版本。

![](https://cdn.jsdelivr.net/gh/ywxgod/image_source/imgs20210528234657.png)



